### ChatBot (cont.)


#### Prologue 
> "“These stone walls, I know it only too well, are steeped in human suffering. I’ve never been able to look at them without a shudder. And yet-believe me, I am speaking from the depths of my heart —I know that even the wretchedest amongst you have sometimes seen, taking form against that grayness, a divine face. It’s that face you are asked to see.”" <br />我非常清楚，這些石牆上承載著人類的苦難。我每次看到它們就渾身發抖。然而──相信我，我是發自內心地說這句話的──我知道，即使是你們中最悲慘的人，有時也會在那灰色的背景下，看到一張神聖的面容。你想看到的就是那張臉。<br />--- The Stranger by Albert Camus"


#### I. Text Searching
There exists three *levels* of search capability in relational database: 

1. Text scan, the [LIKE](https://www.w3schools.com/sql/sql_like.asp) operator in a `WHERE` clause one uses everyday to search for a specified pattern in a column. 
2. Full-text search is a technique that finds specific information within a large corpus of text. It goes beyond keyword matching, and analyzes the content of documents to identify relevant results based on the user's search query
3. Semantic search is a search engine technology that interprets the meaning of words and phrases. The results of a semantic search will return content matching the meaning of a query, as opposed to content that literally matches words in the query.


#### II. Full-text search
To perform more complex full-text searches using `AND`, `OR`, and other operators in Oracle 19c, you can use the `CONTAINS` function with Oracle Text. Here are some examples of how to construct these queries:
```
CREATE TABLE items (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 1) PRIMARY KEY,
    document VARCHAR2(1024)
);

CREATE INDEX items_fts ON items(document) INDEXTYPE IS CTXSYS.CONTEXT;
```

To search for documents containing "maria":
```
SELECT * FROM items
WHERE CONTAINS(document, 'maria') > 0;
```

To search for documents containing both "chan" AND "maria":
```
SELECT * FROM items
WHERE CONTAINS(document, 'chan AND maria') > 0;
```

To search for documents containing either "chan" OR "wong":
```
SELECT * FROM items
WHERE CONTAINS(document, 'chan OR wong') > 0;
```

To search for documents containing "maria" and either "chan" or "wong":
```
SELECT * FROM items
WHERE CONTAINS(document, 'maria AND (chan OR wong)') > 0;
```

To search for documents containing "chan" but not "maria":
```
SELECT * FROM items
WHERE CONTAINS(document, 'chan NOT maria') > 0;
```


#### III. Semantic search
The first step towards [semantic search](https://github.com/Albert0i/RedisVectorSearch/blob/main/SemanticSearch.md) is creating [vector embeddings](https://redis.io/glossary/vector-embeddings/) to capture *semantics* meaning of text to be searched for. In theory, using [llama-cpp](https://github.com/ggml-org/llama.cpp) along with any RDBMS capable of storing Array of Float can achieve the effect of vector semantic search. To begin with, define a `float_array_384` type to be used in storing the embedding. 
```
CREATE OR REPLACE TYPE float_array_384 AS VARRAY(384) OF BINARY_FLOAT;
```

Create the `vec_items` table with ordinary fields plus the `embedding` field. 
```
CREATE TABLE vec_items (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 1) PRIMARY KEY,
    document VARCHAR2(1024),

    embedding float_array_384
);
```
Insert data like so...
```
INSERT INTO vec_items (document, embedding) VALUES ('testing', float_array_384(1.1, 1.2, 1.3, 1.4));
```

The second step is to get a model and transform the text value into vector, which is a high dimension array, programmatically. In our example, we load the `document` field with some text in `vec_items`. And run the embedder to fill in the `embedding` field. 
```
node src/embedder.js 
```

The embedding process is slow and takes quite a while to finish. After that we can use the embeddings to search documents *semantically*... But... how we do that? 

To determine how near or how far of two vectors are we have to get a kind of measurement of distance. [Cosine Similarity and Cosine Distance Explained](https://github.com/Albert0i/RedisVectorSearch/blob/main/cosine.md) is a common approach. 

Create a user defined function `cosine_similarity`: 
```
CREATE OR REPLACE FUNCTION cosine_similarity(
    array1 IN float_array_384,
    array2 IN float_array_384
) RETURN BINARY_FLOAT IS
    dot_product BINARY_FLOAT := 0;
    norm_a BINARY_FLOAT := 0;
    norm_b BINARY_FLOAT := 0;
    similarity BINARY_FLOAT;
BEGIN
    IF array1.COUNT != array2.COUNT THEN
      RAISE_APPLICATION_ERROR(-20001, 'Arrays must be of the same length');
    END IF;

    FOR i IN 1 .. array1.COUNT LOOP
      dot_product := dot_product + (array1(i) * array2(i));
      norm_a := norm_a + (array1(i) * array1(i));
      norm_b := norm_b + (array2(i) * array2(i));
    END LOOP;

    IF norm_a = 0 OR norm_b = 0 THEN
      RETURN 0;
    ELSE
      similarity := dot_product / (SQRT(norm_a) * SQRT(norm_b));
      RETURN similarity;
    END IF;
END cosine_similarity;
/
```

Take a shot like so... 
```
SELECT cosine_similarity(float_array_384(1.1, 1.2, 1.3, 1.4), 
                         float_array_384(1.1, 1.2, 1.5, 1.6)) 
FROM dual;
```

Start the searcher with: 
```
node src/searchersUDF.js
```

It works by reading in query text, creating embedding and feeding it to `findSimilarDocuments` function. 
```
const queryEmbedding = await context.getEmbeddingFor(query);
const similarDocuments = await findSimilarDocuments(queryEmbedding);
```

```
async function findSimilarDocuments(embedding, count = 10) {
    const { vector } = embedding

    const result = await runSelectSQL(`SELECT id, document, 
                                              cosine_similarity(float_array_384(${vector}), embedding) AS score 
                                       FROM vec_items
                                       ORDER BY score DESC  
                                       OFFSET 0 ROWS FETCH NEXT ${count} ROWS ONLY
                                     `)
    if (result.success)
        return result.rows;
    else {
        console.log(result)
        return []
    } 
}
```


#### IV. Summary 
In the year of 2025, I am deeply absorbed in the idea of semantic search... It is COOL! How can a computer understand the meaning of a sentence? Redis was my first step taken, everything there is easy-peasy, as Redis is meant for that and built for that. Later on I learn about [node-llama-cpp](https://www.npmjs.com/package/@node-llama-cpp/linux-x64), [pgvector](https://github.com/pgvector/pgvector) and [sqlite-vec](https://github.com/asg017/sqlite-vec). 

Extraction of semantics of text relies on a model. Different models, of different size and different capability, serve different purposes and there are many pre-trained models available. The one I use here is [paraphrase-MiniLM-L6-v2.i1-IQ1_S.gguf](https://huggingface.co/mradermacher/paraphrase-MiniLM-L6-v2-i1-GGUF/tree/main) (17.8 MB) which is a variant of the **paraphrase-MiniLM-L6-v2** model, and is part of the **sentence-transformers** family. This model is designed to map sentences and paragraphs to a 384-dimensional dense vector space, making it useful for tasks like clustering, semantic search, and sentence similarity[1](https://huggingface.co/sentence-transformers/paraphrase-MiniLM-L6-v2). 

RDBMS is for office tasks while NoSQL is to tackle real life issues. Most data to be used in office are formulated and normalized in table format. These structured data are particularly suitable to be handled in relational database. Real life data are more un-structured than semi-structured, this poses tremendous challenge on storing and processing them in day-to-day life. 

Talking about AI, it should be considered as helpers to human being ONLY. If you have an idea to do something, AI provides a good project layout and starter code for you. Still some answers make you deviated and gone astray. Always remember that you are the master of your own, AI is a servant, is a tool to help. When it does then drop it. 

I wish this document remains undisclosed since some of the testing detail is inconvenient to pen down. 


#### V. Bibliography
1. [Creating Oracle Text Indexes](https://docs.oracle.com/en/database/oracle/oracle-database/19/ccapp/creating-oracle-text-indexes.html#GUID-3505DB0D-B507-4D2E-A157-F16BD79FCF6E)
2. [Oracle Text CONTAINS Query Operators](https://docs.oracle.com/en/database/oracle/oracle-database/21/ccref/oracle-text-CONTAINS-query-operators.html#GUID-6410B783-FC9A-4C99-B3AF-9E0349AA43D1)
3. [Collection Data Types](https://docs.oracle.com/en/database/oracle/oracle-database/19/adobj/collection-data-types.html)
4. [Introduction to semantic search](https://github.com/Albert0i/RedisVectorSearch/blob/main/SemanticSearch.md)
5. [Cosine Similarity and Cosine Distance Explained](https://github.com/Albert0i/RedisVectorSearch/blob/main/cosine.md)
6. [CREATE FUNCTION Statement](https://docs.oracle.com/en/database/oracle/oracle-database/12.2/lnpls/CREATE-FUNCTION-statement.html)
7. [node-llama-cpp](https://www.npmjs.com/package/node-llama-cpp)
8. [Alex Garcia's Blog](https://alexgarcia.xyz/blog/)
9. [oracledb](https://www.npmjs.com/package/oracledb)
10. [The Stranger by Albert Camus](https://www.macobo.com/essays/epdf/CAMUS,%20Albert%20-%20The%20Stranger.pdf)


#### Epilogue
> "And I, too, felt ready to start life all over again. It was as if that great rush of anger had washed me clean, emptied me of hope, and, gazing up at the dark sky spangled with its signs and stars, for the first time, the first, I laid my heart open to the benign indifference of the universe." <br />而我也覺得自己已經準備好要重新開始生活了。彷彿那股巨大的憤怒將我洗淨，掏空了我的希望，當我仰望佈滿星光和標誌的黑暗天空時，我第一次敞開心扉，感受宇宙的仁慈冷漠。<br />--- The Stranger by Albert Camus"


### EOF (2025/03/28)
